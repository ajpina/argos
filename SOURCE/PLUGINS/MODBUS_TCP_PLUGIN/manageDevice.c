 /**
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 *
 * @file          deviceManager.c
 * @author        Wayne Collins
 *          ---   This file is part of the ARGOS_SCADA system   ---
 *                        Copyright (C) 2021 
 *
 * @brief         This function manages one specific device 
 *
 * This function manages the interactions with one specific device. It receives
 * events on a pipe. These event messages are generated by the systems signal 
 * handlers for timer messages, notifications to shutdown or reconfigure and
 * commands received over a message queue.
 *        
 *
 * @param      a pointer to the configuredDevices entry 
 * 
 * ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 */
 
 #include "privateModbusTcpHeader.h"
 
 /* ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  * Use the sizes from the MODBUS library
  * ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  */
 uint8_t data8[ MAX( sizeof( uint8_t ) * MAX(MODBUS_MAX_READ_BITS,MODBUS_MAX_WRITE_BITS),\
                     sizeof( uint16_t) * MAX(MODBUS_MAX_READ_REGISTERS,MODBUS_MAX_WRITE_REGISTERS) \
                   ) ];
 
 uint16_t * data16;
 
void  refreshData( device * D ) {
int i,j,saveError,stride;
void      * shmPointer;
readPlan  * rpA;
modbus_t  * ctx;

    ctx        = ( ( mbTcpControl * )( D->pluginControl ) ) -> mbContext;
    rpA        = ( readPlan * ) ( ( mbTcpControl * )( D->pluginControl ) ) -> readPlanArray;
    shmPointer = D->shmBlock;
    data16     = ( uint16_t * ) data8;
    ARGOS_PRINTF("Refreshing data for device %s\n",D->deviceName);
    for (i = 0; i < dynarray_length( rpA ) ; i++ ) {
        memset( data8, '\0', sizeof( data8 ) );
        switch ( rpA[i].dataType ) {
           case ICOIL_TARGET   :    /* Single Bit Read Only   */
                                    stride = sizeof( uint8_t );
                                    j = modbus_read_input_bits( ctx, 
                                                                rpA[i].startAddr,\
                                                                rpA[i].numberToAccess, 
                                                                data8 );
                                    break;
           case OCOIL_TARGET   :    /* Single Bit Read Write  */
                                    stride = sizeof( uint8_t );
                                    j = modbus_read_bits( ctx, 
                                                          rpA[i].startAddr, 
                                                          rpA[i].numberToAccess, 
                                                          data8 );
                                    break;
           case IREG_TARGET    :    /* Short      Read Only   */
                                    stride = sizeof( uint16_t );
                                    j = modbus_read_input_registers( ctx, 
                                                                     rpA[i].startAddr,
                                                                     rpA[i].numberToAccess, 
                                                                     data16 );
                                    break;
           case HREG_TARGET    :    /* Short      Read Write  */
                                    stride = sizeof( uint16_t );
                                    j = modbus_read_registers( ctx, 
                                                               rpA[i].startAddr,
                                                               rpA[i].numberToAccess, 
                                                               data16 );
                                    break;
           case UNKNOWN_TARGET :    /* +++ Major Problems +++ */
           default             :
                                    break;
        }
        
/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * Read request has been sent to the device and j is either -1 for an
 * error or is the number of registers returned ...
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 */
        if ( j == -1 ) {
           saveError = errno;
           ARGOS_PRINTF("MODBUS error during data read from device %s\n",D->deviceName );
           ARGOS_PRINTF("Error reported <%s>\n",modbus_strerror( saveError ) );
           ARGOS_PRINTF("Last known data left un-modified\n");
        } else {
/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * Move the data we did get into the shared memory block
 * Data we did NOT get (short read) we leave it with the last known 
 * values 
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 */
           memmove( shmPointer, &data8, j * stride );
        }
        shmPointer += rpA[i].numberToAccess * stride;
/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * Do the next step of the read plan ...
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 */ 	
    }
}
 
 void * ARGOS_MODBUS_TCP_manageDevice( void * V ) {
 device  * D;
 int       i,j,saveError,forever = 1;
 fd_set    fds;
 char      message[16];
 
    D = ( device * ) V;
    
    while( forever ) {
      FD_ZERO( &fds );
      FD_SET( D->devicePipe[0], &fds );
      i = select( D->devicePipe[0]+1, &fds, NULL, NULL, NULL ); /* Wait for a message */
      switch ( i ) {
        case EINTR  :
        case     0  :
                       break;
        case    -1  :  saveError = errno;
                       ARGOS_PRINTF("SELECT error with device %s\n",D->deviceName );
                       ARGOS_PRINTF("Error %d  %s\n",saveError,strerror( saveError ) );
                       ARGOS_PRINTF("Continuing ...\n"); 
                       break;
        case     1  :
                       memset( message,'\0', 16 );
                       j = read( D->devicePipe[0], &message, 4 );
                       if ( j != 4 ) {
                       } else {
                          switch ( message[0] ) {
                            case 'Q'   :   /* Asked to terminate     */
                            case 'R'   :   /* Asked to re-configure  */
                                           forever = 0;
                                           break;
                            case 'T'   :   /* Asked to refresh data */
                                           refreshData( D );
                                           break;
                            case 'M'   :   /* Message delivered  */
ARGOS_PRINTF("* *****************************************************************\n");
ARGOS_PRINTF("* Message received n message queue!\n");
ARGOS_PRINTF("* We do NOT know how to handle this yet!!\n");
ARGOS_PRINTF("* Wait for the conversion of other ARGOS programs before you\n");
ARGOS_PRINTF("* send me messages ...\n");
ARGOS_PRINTF("* *****************************************************************\n");
exit(16);
                                           break;                            
                          } 
                       }
      }
    }

    
    return NULL;
 }
